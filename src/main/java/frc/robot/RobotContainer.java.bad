package frc.robot;

import static edu.wpi.first.units.Units.*;

import com.ctre.phoenix6.swerve.SwerveModule.DriveRequestType;
import com.ctre.phoenix6.swerve.SwerveRequest;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
import edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction;

import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.config.RobotConfig;
import com.pathplanner.lib.controllers.PPHolonomicDriveController;
import com.pathplanner.lib.config.PIDConstants;

import frc.robot.commands.DriveToAprilTagCommand;
import frc.robot.commands.DriveToHomeCommand;
import frc.robot.commands.SimpleAutonomousCommand;
import frc.robot.constants.AprilTagConstants;
import frc.robot.generated.TunerConstants;
import frc.robot.subsystems.CommandSwerveDrivetrain;

public class RobotContainer {
  private final double MaxSpeed = TunerConstants.kSpeedAt12Volts.in(MetersPerSecond);
  private final double MaxAngularRate = RotationsPerSecond.of(0.75).in(RadiansPerSecond);
  private final com.ctre.phoenix6.swerve.SwerveRequest.RobotCentric robotDrive = new com.ctre.phoenix6.swerve.SwerveRequest.RobotCentric()
      .withDeadband(MaxSpeed * 0.1)
      .withRotationalDeadband(MaxAngularRate * 0.1)
      .withDriveRequestType(com.ctre.phoenix6.swerve.SwerveModule.DriveRequestType.OpenLoopVoltage);
  private final com.ctre.phoenix6.swerve.SwerveRequest.FieldCentric fieldDrive = new com.ctre.phoenix6.swerve.SwerveRequest.FieldCentric()
      .withDeadband(MaxSpeed * 0.1)
      .withRotationalDeadband(MaxAngularRate * 0.1)
      .withDriveRequestType(com.ctre.phoenix6.swerve.SwerveModule.DriveRequestType.OpenLoopVoltage);
  private boolean fieldMode = false; // false=Robot-centric (default), true=Field-centric
  private final java.util.function.Supplier<java.util.Optional<edu.wpi.first.math.geometry.Pose2d>> tag2VisionSupplier =
      frc.robot.vision.PhotonVisionWrapper.tagPoseSupplier("photonCam", 2);
  private static final edu.wpi.first.math.geometry.Pose2d SAFE_POSE = new edu.wpi.first.math.geometry.Pose2d(3.0, 3.0, new edu.wpi.first.math.geometry.Rotation2d());

  private final SwerveRequest.SwerveDriveBrake brake = new SwerveRequest.SwerveDriveBrake();
  private final SwerveRequest.PointWheelsAt point = new SwerveRequest.PointWheelsAt();

  private final Field2d field = new Field2d();           // Field widget
  private final Telemetry logger;                        // <-- declare only

  public final CommandSwerveDrivetrain drivetrain = TunerConstants.createDrivetrain();
  private final CommandXboxController joystick = new CommandXboxController(0);

  private SendableChooser<Command> autoChooser;

  

  public RobotContainer() {
    // 1) PathPlanner hooks
    private void configurePathPlanner() {
      // Example: configure AutoBuilder for holonomic swerve
      // (Adjust getters to your drivetrain API and tune the gains.)
      
      var rotationDelay = new edu.wpi.first.math.controller.ProfiledPIDController(5.0,
          0.0, 0.0, new edu.wpi.first.math.trajectory.TrapezoidProfile.Constraints(
              Math.toRadians(540), Math.toRadians(720)));
    
      com.pathplanner.lib.auto.AutoBuilder.configureHolonomic(
          drivetrain::getPose,
          drivetrain::resetPose,
          drivetrain::getChassisSpeeds,
          drivetrain::driveChassisSpeeds,
          new com.pathplanner.lib.util.HolonomicPathFollowerConfig(
              new com.pathplanner.lib.util.PIDConstants(6.0, 0.0, 0.0),    // translation
              new com.pathplanner.lib.util.PIDConstants(5.0, 0.0, 0.0),    // rotation
              MaxSpeed,                                                    // m/s
              0.45,                                                        // drive base radius (m) — tune
              new com.pathplanner.lib.util.ReplanningConfig()
          ),
          () -> fieldMode, // true=Field-centric; if you prefer alliance mirroring, swap for alliance supplier
          drivetrain
      );
    
    }
    

    // 2) Chooser before adding options
    createAutoChooser();

    // 3) Expose field widget & create telemetry
    SmartDashboard.putData("Field", field);
    logger = new Telemetry(MaxSpeed, field);            // <-- construct once

    // 4) Default teleop drive
    drivetrain.setDefaultCommand(
    drivetrain.applyRequest(() -> {
      double scale = (joystick.getLeftTriggerAxis() > 0.2) ? 0.35
          : ((joystick.getRightTriggerAxis() > 0.2) ? 1.0 : 0.8);
      if (fieldMode) {
        return fieldDrive
            .withVelocityX(-joystick.getLeftY() * MaxSpeed * scale)
            .withVelocityY(-joystick.getLeftX() * MaxSpeed * scale)
            .withRotationalRate(-joystick.getRightX() * MaxAngularRate * scale);
      } else {
        return robotDrive
            .withVelocityX(-joystick.getLeftY() * MaxSpeed * scale)
            .withVelocityY(-joystick.getLeftX() * MaxSpeed * scale)
            .withRotationalRate(-joystick.getRightX() * MaxAngularRate * scale);
      }
    })
);

    // 5) Buttons and SysId
    configureBindings();

    // 6) Add custom auto options
    populateAutoChooser();

    // 7) Feed telemetry (this updates Field2d via Telemetry.telemeterize)
    drivetrain.registerTelemetry(logger::telemeterize);
  }

  private void configureBindings() {
  // X: Align 2 ft (0.6096 m) in front of AprilTag #2, facing it (vision preferred)
  joystick.x().onTrue(new frc.robot.commands.DriveToAprilTagOffsetOrVisionCommand(
      drivetrain, 2, 0.6096, tag2VisionSupplier));

  // Y: Move to SAFE_POSE
  joystick.y().onTrue(new frc.robot.commands.PathPlannerNavigationCommand(
      drivetrain, SAFE_POSE, frc.robot.utils.PathPlannerUtils.getDefaultPathConstraints(), "Safe Position"));

  // A: Cancel all & brief brake, then manual Robot-centric
  joystick.a().onTrue(
      edu.wpi.first.wpilibj2.command.Commands.runOnce(() -> {
        edu.wpi.first.wpilibj2.command.CommandScheduler.getInstance().cancelAll();
        fieldMode = false; // back to Robot-centric
        System.out.println("[Auto] Cancelled and returned to Robot-Centric manual control");
      }).andThen(drivetrain.applyRequest(() -> brake)).withTimeout(0.25)
  );

  // B (hold): Point wheels toward left-stick direction (azimuth only)
  joystick.b().whileTrue(
      drivetrain.applyRequest(() -> {
        double vx = -joystick.getLeftY();
        double vy = -joystick.getLeftX();
        var dir = new edu.wpi.first.math.geometry.Rotation2d(Math.atan2(vy, vx));
        return point.withModuleDirection(dir);
      })
  );

  // LB: Toggle Robot-centric ↔ Field-centric (auto-seed when switching to Field)
  joystick.leftBumper().onTrue(edu.wpi.first.wpilibj2.command.Commands.runOnce(() -> {
    if (!fieldMode) {
      fieldMode = true;
      drivetrain.seedFieldCentric();
      System.out.println("[DriveMode] Switched to Field-Centric (seeded)");
    } else {
      fieldMode = false;
      System.out.println("[DriveMode] Switched to Robot-Centric");
    }
  }));

  // RB (hold): Brake (guarded so RB+A still triggers Home)
  joystick.rightBumper().and(joystick.a().negate()).whileTrue(drivetrain.applyRequest(() -> brake));
  // RB + A: Home
  joystick.rightBumper().and(joystick.a()).onTrue(new frc.robot.commands.DriveToHomeCommand(drivetrain));

  // SysId (WPILib sysid Direction)
  joystick.back().and(joystick.povUp()).whileTrue(drivetrain.sysIdDynamic(edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction.kForward));
  joystick.back().and(joystick.povDown()).whileTrue(drivetrain.sysIdDynamic(edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction.kReverse));
  joystick.start().and(joystick.povUp()).whileTrue(drivetrain.sysIdQuasistatic(edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction.kForward));
  joystick.start().and(joystick.povDown()).whileTrue(drivetrain.sysIdQuasistatic(edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine.Direction.kReverse));
}

  private void createAutoChooser() {
    try {
      autoChooser = AutoBuilder.buildAutoChooser();
    } catch (IllegalStateException ex) {
      autoChooser = new SendableChooser<>();
      System.err.println("[Auto] AutoBuilder not configured, using empty chooser: " + ex.getMessage());
    }
    SmartDashboard.putData("Auto Chooser", autoChooser);
  }

  private void populateAutoChooser() {
    autoChooser.setDefaultOption("Do Nothing", Commands.none());
    autoChooser.addOption("Drive Forward 2s", SimpleAutonomousCommand.driveForward(drivetrain, 2.0));
    autoChooser.addOption("Spin In Place 2s", SimpleAutonomousCommand.spinInPlace(drivetrain, 2.0));
    autoChooser.addOption("Square Pattern", SimpleAutonomousCommand.squarePattern(drivetrain));
    autoChooser.addOption("PathPlanner: TestAuto1", AutoBuilder.buildAuto("TestAuto1"));
    autoChooser.addOption(
      "PathPlanner: Simple Test",
      Commands.sequence(
          Commands.print("PathPlanner: Starting simple test"),
          Commands.runOnce(() -> {
              System.out.println("[PathPlanner] Current pose: " + drivetrain.getPose());
              System.out.println("[PathPlanner] Robot config loaded: " + (AutoBuilder.isConfigured() ? "YES" : "NO"));
          }),
          Commands.waitSeconds(1.0),
          Commands.print("PathPlanner: Simple test complete")
      )
  );

  }

  public Command getAutonomousCommand() {
    return autoChooser != null ? autoChooser.getSelected() : Commands.none();
  }
}
